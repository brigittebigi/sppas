<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>anndata.aio.elan &mdash; SPPAS 1.9.8 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.9.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="SPPAS 1.9.8 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SPPAS 1.9.8 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for anndata.aio.elan</h1><div class="highlight"><pre>
<span class="c"># -*- coding: UTF-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ..</span>
<span class="sd">        ---------------------------------------------------------------------</span>
<span class="sd">         ___   __    __    __    ___</span>
<span class="sd">        /     |  \  |  \  |  \  /              the automatic</span>
<span class="sd">        \__   |__/  |__/  |___| \__             annotation and</span>
<span class="sd">           \  |     |     |   |    \             analysis</span>
<span class="sd">        ___/  |     |     |   | ___/              of speech</span>

<span class="sd">        http://www.sppas.org/</span>

<span class="sd">        Use of this software is governed by the GNU Public License, version 3.</span>

<span class="sd">        SPPAS is free software: you can redistribute it and/or modify</span>
<span class="sd">        it under the terms of the GNU General Public License as published by</span>
<span class="sd">        the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">        (at your option) any later version.</span>

<span class="sd">        SPPAS is distributed in the hope that it will be useful,</span>
<span class="sd">        but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">        GNU General Public License for more details.</span>

<span class="sd">        You should have received a copy of the GNU General Public License</span>
<span class="sd">        along with SPPAS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">        This banner notice must not be removed.</span>

<span class="sd">        ---------------------------------------------------------------------</span>

<span class="sd">    src.anndata.aio.elan.py</span>
<span class="sd">    ~~~~~~~~~~~~~~~~~~~~~~~</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">xml.etree.cElementTree</span> <span class="kn">as</span> <span class="nn">ET</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">sppas</span>
<span class="kn">from</span> <span class="nn">sppas.src.resources.mapping</span> <span class="kn">import</span> <span class="n">sppasMapping</span>
<span class="kn">from</span> <span class="nn">sppas.src.utils.datatype</span> <span class="kn">import</span> <span class="n">sppasTime</span>

<span class="kn">from</span> <span class="nn">..anndataexc</span> <span class="kn">import</span> <span class="n">AnnDataTypeError</span>
<span class="kn">from</span> <span class="nn">..anndataexc</span> <span class="kn">import</span> <span class="n">AioFormatError</span>
<span class="kn">from</span> <span class="nn">..anndataexc</span> <span class="kn">import</span> <span class="n">CtrlVocabSetTierError</span>
<span class="kn">from</span> <span class="nn">..anndataexc</span> <span class="kn">import</span> <span class="n">CtrlVocabContainsError</span>
<span class="kn">from</span> <span class="nn">..annlocation.location</span> <span class="kn">import</span> <span class="n">sppasLocation</span>
<span class="kn">from</span> <span class="nn">..annlocation.point</span> <span class="kn">import</span> <span class="n">sppasPoint</span>
<span class="kn">from</span> <span class="nn">..annlocation.interval</span> <span class="kn">import</span> <span class="n">sppasInterval</span>
<span class="kn">from</span> <span class="nn">..annlabel.label</span> <span class="kn">import</span> <span class="n">sppasLabel</span>
<span class="kn">from</span> <span class="nn">..annlabel.tag</span> <span class="kn">import</span> <span class="n">sppasTag</span>
<span class="kn">from</span> <span class="nn">..media</span> <span class="kn">import</span> <span class="n">sppasMedia</span>
<span class="kn">from</span> <span class="nn">..tier</span> <span class="kn">import</span> <span class="n">sppasTier</span>
<span class="kn">from</span> <span class="nn">..hierarchy</span> <span class="kn">import</span> <span class="n">sppasHierarchy</span>
<span class="kn">from</span> <span class="nn">..annotation</span> <span class="kn">import</span> <span class="n">sppasAnnotation</span>

<span class="kn">from</span> <span class="nn">..ctrlvocab</span> <span class="kn">import</span> <span class="n">sppasCtrlVocab</span>

<span class="kn">from</span> <span class="nn">.basetrs</span> <span class="kn">import</span> <span class="n">sppasBaseIO</span>
<span class="kn">from</span> <span class="nn">.aioutils</span> <span class="kn">import</span> <span class="n">format_labels</span>
<span class="kn">from</span> <span class="nn">.aioutils</span> <span class="kn">import</span> <span class="n">point2interval</span>
<span class="kn">from</span> <span class="nn">.aioutils</span> <span class="kn">import</span> <span class="n">merge_overlapping_annotations</span>

<span class="c"># ---------------------------------------------------------------------------</span>

<span class="n">ETYPES</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;iso12620&#39;</span><span class="p">,</span>
          <span class="s">&#39;ecv&#39;</span><span class="p">,</span>
          <span class="s">&#39;cve_id&#39;</span><span class="p">,</span>
          <span class="s">&#39;lexen_id&#39;</span><span class="p">,</span>
          <span class="s">&#39;resource_url&#39;</span><span class="p">}</span>

<span class="n">CONSTRAINTS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;Time_Subdivision&#39;</span><span class="p">:</span> <span class="s">&quot;Time subdivision of parent annotation&#39;s time inte&quot;</span>
    <span class="s">&#39;rval, no time gaps allowed within this interval&#39;</span><span class="p">,</span>
    <span class="s">&#39;Symbolic_Subdivision&#39;</span><span class="p">:</span> <span class="s">&#39;Symbolic subdivision of a parent annotation. &#39;</span>
    <span class="s">&#39;Annotations refering to the same parent are ordered&#39;</span><span class="p">,</span>
    <span class="s">&#39;Symbolic_Association&#39;</span><span class="p">:</span> <span class="s">&#39;1-1 association with a parent annotation&#39;</span><span class="p">,</span>
    <span class="s">&#39;Included_In&#39;</span><span class="p">:</span> <span class="s">&#39;Time alignable annotations within the parent annotation</span><span class="se">\&#39;</span><span class="s">s &#39;</span>
                   <span class="s">&#39;time interval, gaps are allowed&#39;</span><span class="p">}</span>

<span class="n">MIMES</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;wav&#39;</span><span class="p">:</span> <span class="s">&#39;audio/x-wav&#39;</span><span class="p">,</span>
         <span class="s">&#39;mpg&#39;</span><span class="p">:</span> <span class="s">&#39;video/mpeg&#39;</span><span class="p">,</span>
         <span class="s">&#39;mpeg&#39;</span><span class="p">:</span> <span class="s">&#39;video/mpg&#39;</span><span class="p">,</span>
         <span class="s">&#39;xml&#39;</span><span class="p">:</span> <span class="s">&#39;text/xml&#39;</span><span class="p">}</span>

<span class="c"># ---------------------------------------------------------------------------</span>


<div class="viewcode-block" id="sppasEAF"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF">[docs]</a><span class="k">class</span> <span class="nc">sppasEAF</span><span class="p">(</span><span class="n">sppasBaseIO</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :author:       Brigitte Bigi</span>
<span class="sd">    :organization: Laboratoire Parole et Langage, Aix-en-Provence, France</span>
<span class="sd">    :contact:      brigitte.bigi@gmail.com</span>
<span class="sd">    :license:      GPL, v3</span>
<span class="sd">    :copyright:    Copyright (C) 2011-2018  Brigitte Bigi</span>
<span class="sd">    :summary:      SPPAS ELAN EAF files reader and writer.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="sppasEAF.detect"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.detect">[docs]</a>    <span class="k">def</span> <span class="nf">detect</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check whether a file is of EAF format or not.</span>

<span class="sd">        :param filename: (str) Name of the file to check.</span>
<span class="sd">        :returns: (bool)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                    <span class="k">if</span> <span class="s">&quot;&lt;ANNOTATION_DOCUMENT&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="c"># -----------------------------------------------------------------------</span>
</div>
<div class="viewcode-block" id="sppasEAF.__init__"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize a new sppasMLF instance.</span>

<span class="sd">        :param name: (str) This transcription name.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>

        <span class="n">sppasBaseIO</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_multi_tiers</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_no_tiers</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_metadata</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_ctrl_vocab</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_media</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_hierarchy</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_point</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_interval</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_disjoint</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_alt_localization</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_alt_tag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_radius</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_gaps</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accept_overlaps</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># to be verified</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_extension</span> <span class="o">=</span> <span class="s">&quot;eaf&quot;</span>

        <span class="c"># Information that are both used by ELAN and another software tool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_meta</span> <span class="o">=</span> <span class="n">sppasMapping</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_meta</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;PARTICIPANT&#39;</span><span class="p">,</span> <span class="s">&#39;speaker_name&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_meta</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;ANNOTATOR&#39;</span><span class="p">,</span> <span class="s">&#39;annotator_name&#39;</span><span class="p">)</span>

        <span class="c"># ELAN only supports (and assumes) milliseconds.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="mf">0.001</span>

    <span class="c"># -----------------------------------------------------------------------</span>
</div>
<div class="viewcode-block" id="sppasEAF.make_point"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.make_point">[docs]</a>    <span class="k">def</span> <span class="nf">make_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">midpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert data into the appropriate sppasPoint().</span>

<span class="sd">        :param midpoint: (str) a time in ELAN format</span>
<span class="sd">        :returns: (sppasPoint) Representation of time in seconds with a (very)</span>
<span class="sd">        large vagueness!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AnnDataTypeError</span><span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="s">&quot;float&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sppasPoint</span><span class="p">(</span><span class="n">midpoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>
</div>
<div class="viewcode-block" id="sppasEAF.format_point"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.format_point">[docs]</a>    <span class="k">def</span> <span class="nf">format_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">second_count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert a time in seconds into ELAN format.</span>

<span class="sd">        :param second_count: (float) Time value (in seconds)</span>
<span class="sd">        :returns: (int) a time in ELAN format</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">second_count</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">second_count</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AnnDataTypeError</span><span class="p">(</span><span class="n">second_count</span><span class="p">,</span> <span class="s">&quot;float&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">second_count</span><span class="p">))</span>

    <span class="c"># -----------------------------------------------------------------------</span>
    <span class="c"># reader</span>
    <span class="c"># -----------------------------------------------------------------------</span>
</div>
<div class="viewcode-block" id="sppasEAF.read"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a ELAN EAF file.</span>

<span class="sd">        :param filename: (str) input filename.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

        <span class="c"># 1. Document</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_document</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 2. License (0..*)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">license_root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;LICENSE&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_license</span><span class="p">(</span><span class="n">license_root</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c"># 3. Header (1..1)</span>
        <span class="n">header_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;HEADER&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">header_root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AioFormatError</span><span class="p">(</span><span class="s">&#39;HEADER&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_header</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;HEADER&#39;</span><span class="p">))</span>

        <span class="c"># 4. Time order (1..1)</span>
        <span class="n">time_order_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;TIME_ORDER&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_order_root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AioFormatError</span><span class="p">(</span><span class="s">&#39;TIME_ORDER&#39;</span><span class="p">)</span>
        <span class="n">time_slots</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_parse_time_order</span><span class="p">(</span><span class="n">time_order_root</span><span class="p">)</span>

        <span class="c"># 5. Controlled vocabularies (0..*)</span>
        <span class="k">for</span> <span class="n">vocabulary_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;CONTROLLED_VOCABULARY&#39;</span><span class="p">):</span>
            <span class="n">ctrl_vocab</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_parse_ctrl_vocab</span><span class="p">(</span><span class="n">vocabulary_root</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ctrl_vocab</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_ctrl_vocab</span><span class="p">(</span><span class="n">ctrl_vocab</span><span class="p">)</span>

        <span class="c"># 6. Tiers (0..*)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_tiers</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">)</span>

        <span class="c"># 7. Linguistic type</span>
        <span class="k">for</span> <span class="n">linguistic_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_linguistic_type</span><span class="p">(</span><span class="n">linguistic_root</span><span class="p">)</span>

        <span class="c"># 8. Locale (0..*)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">locale_root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;LOCALE&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_locale</span><span class="p">(</span><span class="n">locale_root</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c"># 9. Language</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">language_root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;LANGUAGE&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_language</span><span class="p">(</span><span class="n">language_root</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c"># 10. Constraint</span>

        <span class="c"># 11. Lexicon ref</span>

        <span class="c"># 12. External ref</span>

    <span class="c"># -----------------------------------------------------------------------</span>
</div>
    <span class="k">def</span> <span class="nf">_parse_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the main element root.</span>

<span class="sd">        :param document_root: (ET) Main root.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&quot;DATE&quot;</span> <span class="ow">in</span> <span class="n">document_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;file_created_date&#39;</span><span class="p">,</span> <span class="n">document_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;DATE&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s">&quot;VERSION&quot;</span> <span class="ow">in</span> <span class="n">document_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;file_created_format_version&#39;</span><span class="p">,</span> <span class="n">document_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;VERSION&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s">&quot;AUTHOR&quot;</span> <span class="ow">in</span> <span class="n">document_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;file_created_author&#39;</span><span class="p">,</span> <span class="n">document_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;AUTHOR&#39;</span><span class="p">])</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_license</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">license_root</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get an element &#39;LICENSE&#39;.</span>
<span class="sd">        The current version of ELAN does not yet provide a means to edit</span>
<span class="sd">        or view the contents of the license.</span>

<span class="sd">        :param license_root: (ET) License root.</span>
<span class="sd">        :param idx: (int) Index of the license</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;file_license_text_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">license_root</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="s">&quot;LICENSE_URL&quot;</span> <span class="ow">in</span> <span class="n">license_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;file_license_url_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">license_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LICENSE_URL&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;file_license_url_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the element &#39;HEADER&#39;.</span>
<span class="sd">        There should be exactly one HEADER element. It can contain sequences</span>
<span class="sd">        of three elements and has two attributes.</span>

<span class="sd">        :param header_root: (ET) Header root.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Fix the time unit</span>
        <span class="n">unit_string</span> <span class="o">=</span> <span class="n">header_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_UNITS&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">unit_string</span> <span class="o">==</span> <span class="s">&#39;seconds&#39;</span><span class="p">:</span>
            <span class="c"># it should never happen if the EAF file was generated with Elan software</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">for</span> <span class="n">media_root</span> <span class="ow">in</span> <span class="n">header_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;MEDIA_DESCRIPTOR&#39;</span><span class="p">):</span>
            <span class="n">media</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_parse_media_descriptor</span><span class="p">(</span><span class="n">media_root</span><span class="p">,</span> <span class="n">header_root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_media</span><span class="p">(</span><span class="n">media</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">linked_root</span> <span class="ow">in</span> <span class="n">header_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;LINKED_FILE_DESCRIPTOR&#39;</span><span class="p">):</span>
            <span class="n">media</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_parse_linked_file_descriptor</span><span class="p">(</span><span class="n">linked_root</span><span class="p">,</span> <span class="n">header_root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_media</span><span class="p">(</span><span class="n">media</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">property_root</span> <span class="ow">in</span> <span class="n">header_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;PROPERTY&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_property</span><span class="p">(</span><span class="n">property_root</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_media_descriptor</span><span class="p">(</span><span class="n">media_root</span><span class="p">,</span> <span class="n">header_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;MEDIA_DESCRIPTOR&#39;.</span>
<span class="sd">        This element describes one primary media source.</span>
<span class="sd">        Create a sppasMedia instance and add it.</span>

<span class="sd">        :param media_root: (ET) Media root element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">media_url</span> <span class="o">=</span> <span class="n">media_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;MEDIA_URL&#39;</span><span class="p">]</span>
        <span class="n">media_mime</span> <span class="o">=</span> <span class="n">media_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;MIME_TYPE&#39;</span><span class="p">]</span>

        <span class="c"># Create the new Media and put all information in metadata</span>
        <span class="n">media</span> <span class="o">=</span> <span class="n">sppasMedia</span><span class="p">(</span><span class="n">media_url</span><span class="p">,</span> <span class="n">mime_type</span><span class="o">=</span><span class="n">media_mime</span><span class="p">)</span>
        <span class="n">media</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;media_source&#39;</span><span class="p">,</span> <span class="s">&#39;primary&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RELATIVE_MEDIA_URL&#39;</span><span class="p">,</span> <span class="s">&#39;TIME_ORIGIN&#39;</span><span class="p">,</span> <span class="s">&#39;EXTRACTED_FROM&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">media_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">media</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="n">media_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">attrib</span><span class="p">])</span>

        <span class="c"># media identifier</span>
        <span class="k">for</span> <span class="n">property_root</span> <span class="ow">in</span> <span class="n">header_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;PROPERTY&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s">&#39;NAME&#39;</span> <span class="ow">in</span> <span class="n">property_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">property_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;NAME&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;media_id_&#39;</span><span class="o">+</span><span class="n">media</span><span class="o">.</span><span class="n">get_filename</span><span class="p">():</span>
                    <span class="n">media</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">property_root</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">media</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_linked_file_descriptor</span><span class="p">(</span><span class="n">linked_root</span><span class="p">,</span> <span class="n">header_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;LINKED_FILE_DESCRIPTOR&#39;.</span>
<span class="sd">        This element describes a “secondary”, additional source.</span>
<span class="sd">        Create a sppasMedia instance and add it.</span>

<span class="sd">        :param linked_root: (ET) Linked file descriptor root element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">media_url</span> <span class="o">=</span> <span class="n">linked_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LINK_URL&#39;</span><span class="p">]</span>
        <span class="n">media_mime</span> <span class="o">=</span> <span class="n">linked_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;MIME_TYPE&#39;</span><span class="p">]</span>

        <span class="c"># Create the new Media and put all information in metadata</span>
        <span class="n">media</span> <span class="o">=</span> <span class="n">sppasMedia</span><span class="p">(</span><span class="n">media_url</span><span class="p">,</span> <span class="n">mime_type</span><span class="o">=</span><span class="n">media_mime</span><span class="p">)</span>
        <span class="n">media</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;media_source&#39;</span><span class="p">,</span> <span class="s">&#39;secondary&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RELATIVE_LINK_URL&#39;</span><span class="p">,</span> <span class="s">&#39;TIME_ORIGIN&#39;</span><span class="p">,</span> <span class="s">&#39;ASSOCIATED_WITH&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">linked_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">media</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="n">linked_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">attrib</span><span class="p">])</span>

        <span class="c"># media identifier</span>
        <span class="k">for</span> <span class="n">property_root</span> <span class="ow">in</span> <span class="n">header_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;PROPERTY&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s">&#39;NAME&#39;</span> <span class="ow">in</span> <span class="n">property_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">property_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;NAME&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;media_id_&#39;</span><span class="o">+</span><span class="n">media</span><span class="o">.</span><span class="n">get_filename</span><span class="p">():</span>
                    <span class="n">media</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">property_root</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">media</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">property_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;PROPERTY&#39; -&gt; sppasMetadata().</span>
<span class="sd">        This is a general purpose element for storing key-value pairs.</span>

<span class="sd">        This method store all metadata except the identifiers (media, tier...).</span>

<span class="sd">        :param property_root: (ET) Property root element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;NAME&#39;</span> <span class="ow">in</span> <span class="n">property_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">property_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;NAME&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s">&quot;_id_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">property_root</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">property_root</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_locale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locale_root</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get an element &#39;LOCALE&#39;.</span>

<span class="sd">        :param locale_root: (ET) Locale root.</span>
<span class="sd">        :param idx: (int) Index of the locale</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;locale_code_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">locale_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LANGUAGE_CODE&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s">&quot;COUNTRY_CODE&quot;</span> <span class="ow">in</span> <span class="n">locale_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;locale_country_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">locale_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;COUNTRY_CODE&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s">&quot;VARIANT&quot;</span> <span class="ow">in</span> <span class="n">locale_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;locale_variant_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">locale_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;VARIANT&#39;</span><span class="p">])</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_language</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">language_root</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get an element &#39;LANGUAGE&#39;.</span>

<span class="sd">        Extracted information are:</span>
<span class="sd">            - language iso639-3 code,</span>
<span class="sd">            - language name,</span>
<span class="sd">            - language url, except if cdb.iso.org which is wrong (changed to the SIL one).</span>

<span class="sd">        :param language_root: (ET) Language element.</span>
<span class="sd">        :param idx: (int) Index of the language</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iso</span> <span class="o">=</span> <span class="n">language_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LANG_ID&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;language_code_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">iso</span><span class="p">)</span>

        <span class="k">if</span> <span class="s">&quot;LANG_LABEL&quot;</span> <span class="ow">in</span> <span class="n">language_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;language_name_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">language_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LANG_LABEL&#39;</span><span class="p">])</span>

        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://iso639-3.sil.org/code/&#39;</span><span class="o">+</span><span class="n">iso</span>
        <span class="k">if</span> <span class="s">&quot;LANG_DEF&quot;</span> <span class="ow">in</span> <span class="n">language_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">=</span> <span class="n">language_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LANG_DEF&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s">&#39;cdb.iso.org&#39;</span> <span class="ow">in</span> <span class="n">url</span><span class="p">:</span>
                <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://iso639-3.sil.org/code/&#39;</span><span class="o">+</span><span class="n">iso</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;language_url_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_time_order</span><span class="p">(</span><span class="n">time_order_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;TIME_ORDER&#39;.</span>
<span class="sd">        The TIME_ORDER element is a container for ordered TIME_SLOT elements.</span>

<span class="sd">        :param time_order_root: (ET) Time order root element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_slots</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c"># parse each of the &lt;TIME_SLOT&gt; elements</span>
        <span class="k">for</span> <span class="n">time_slot_node</span> <span class="ow">in</span> <span class="n">time_order_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIME_SLOT&#39;</span><span class="p">):</span>
            <span class="n">time_id</span> <span class="o">=</span> <span class="n">time_slot_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_SLOT_ID&#39;</span><span class="p">]</span>

            <span class="c"># time slots without time values are ignored.</span>
            <span class="k">if</span> <span class="s">&#39;TIME_VALUE&#39;</span> <span class="ow">in</span> <span class="n">time_slot_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">time_slot_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_VALUE&#39;</span><span class="p">]</span>
                <span class="n">time_slots</span><span class="p">[</span><span class="n">time_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">time_slots</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_ctrl_vocab</span><span class="p">(</span><span class="n">ctrl_vocab_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;CONTROLLED_VOCABULARY&#39; -&gt; sppasCtrlVocab().</span>

<span class="sd">        In version &gt;= 2.8, the locale is ignored.</span>

<span class="sd">        :param ctrl_vocab_root: (ET) Controlled vocabulary root element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create a sppasCtrlVocab instance</span>
        <span class="n">vocab_id</span> <span class="o">=</span> <span class="n">ctrl_vocab_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;CV_ID&#39;</span><span class="p">]</span>
        <span class="n">ctrl_vocab</span> <span class="o">=</span> <span class="n">sppasCtrlVocab</span><span class="p">(</span><span class="n">vocab_id</span><span class="p">)</span>

        <span class="c"># Description</span>
        <span class="k">for</span> <span class="n">descr_node</span> <span class="ow">in</span> <span class="n">ctrl_vocab_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;DESCRIPTION&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">descr_node</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="n">descr_node</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;LANG_REF&#39;</span> <span class="ow">in</span> <span class="n">descr_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;language_code_0&#39;</span><span class="p">,</span> <span class="n">descr_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LANG_REF&#39;</span><span class="p">])</span>

        <span class="c"># Add the list of entries</span>
        <span class="c"># if Elan eaf format &lt; 2.8</span>
        <span class="k">for</span> <span class="n">entry_node</span> <span class="ow">in</span> <span class="n">ctrl_vocab_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;CV_ENTRY&#39;</span><span class="p">):</span>
            <span class="n">entry_text</span> <span class="o">=</span> <span class="n">entry_node</span><span class="o">.</span><span class="n">text</span>
            <span class="n">entry_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
            <span class="k">if</span> <span class="s">&quot;DESCRIPTION&quot;</span> <span class="ow">in</span> <span class="n">entry_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">entry_desc</span> <span class="o">=</span> <span class="n">entry_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;DESCRIPTION&#39;</span><span class="p">]</span>
            <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sppasTag</span><span class="p">(</span><span class="n">entry_text</span><span class="p">),</span> <span class="n">entry_desc</span><span class="p">)</span>

        <span class="c"># if Elan eaf format &gt;= 2.8</span>
        <span class="k">for</span> <span class="n">entry_node</span> <span class="ow">in</span> <span class="n">ctrl_vocab_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;CV_ENTRY_ML&#39;</span><span class="p">):</span>
            <span class="n">entry_value_node</span> <span class="o">=</span> <span class="n">entry_node</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;CVE_VALUE&#39;</span><span class="p">)</span>
            <span class="n">entry_text</span> <span class="o">=</span> <span class="n">entry_value_node</span><span class="o">.</span><span class="n">text</span>
            <span class="n">entry_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
            <span class="k">if</span> <span class="s">&quot;DESCRIPTION&quot;</span> <span class="ow">in</span> <span class="n">entry_value_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">entry_desc</span> <span class="o">=</span> <span class="n">entry_value_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;DESCRIPTION&#39;</span><span class="p">]</span>
            <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sppasTag</span><span class="p">(</span><span class="n">entry_text</span><span class="p">),</span> <span class="n">entry_desc</span><span class="p">)</span>
        <span class="c"># mutually exclusive with a sequence of CV_ENTRY_ML elements:</span>
        <span class="k">if</span> <span class="s">&#39;EXT_REF&#39;</span> <span class="ow">in</span> <span class="n">ctrl_vocab_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">ctrl_vocab_url</span> <span class="o">=</span> <span class="n">ctrl_vocab_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;EXT_REF&#39;</span><span class="p">]</span>
            <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;EXT_REF&#39;</span><span class="p">,</span> <span class="n">ctrl_vocab_url</span><span class="p">)</span>
            <span class="c"># todo: open and parse the ctrl vocab external file.</span>

        <span class="k">return</span> <span class="n">ctrl_vocab</span>

    <span class="c"># -----------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_linguistic_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linguistic_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;LINGUISTIC_TYPE&#39;.</span>

<span class="sd">        This is a collection of attributes and constraints for TIER objects.</span>

<span class="sd">        :param linguistic_root: (ET) Tier root.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linguistic_type</span> <span class="o">=</span> <span class="n">linguistic_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LINGUISTIC_TYPE_ID&#39;</span><span class="p">]</span>

        <span class="c"># which tier is using this linguistic type?</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">linguistic_type</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_REF&#39;</span><span class="p">):</span>

                <span class="c"># Add linguistic type info in the metadata of the tier</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;CONSTRAINTS&#39;</span><span class="p">,</span> <span class="s">&#39;GRAPHIC_REFERENCES&#39;</span><span class="p">,</span> <span class="s">&#39;TIME_ALIGNABLE&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">linguistic_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                        <span class="n">tier</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">linguistic_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

                <span class="c"># Associate tier with a controlled vocabulary</span>
                <span class="k">if</span> <span class="s">&#39;CONTROLLED_VOCABULARY_REF&#39;</span> <span class="ow">in</span> <span class="n">linguistic_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                    <span class="n">ctrl_vocab_name</span> <span class="o">=</span> <span class="n">sppasCtrlVocab</span><span class="p">(</span><span class="n">linguistic_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;CONTROLLED_VOCABULARY_REF&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
                    <span class="n">ctrl_vocab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ctrl_vocab_from_name</span><span class="p">(</span><span class="n">ctrl_vocab_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ctrl_vocab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">tier</span><span class="o">.</span><span class="n">set_ctrl_vocab</span><span class="p">(</span><span class="n">ctrl_vocab</span><span class="p">)</span>
                        <span class="k">except</span> <span class="n">CtrlVocabContainsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="c"># There&#39;s a bug in Elan: accepts non-controlled text in controlled tier</span>
                            <span class="n">tier</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&quot;controlled_vocabulary&quot;</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">))</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">CtrlVocabSetTierError</span><span class="p">(</span><span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">())))</span>
                        <span class="c"># todo: CtrlVocab &lt;-&gt; Tier must deal with the locale...</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># what to do with an unused linguistic type?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_tiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get all the elements &#39;TIER&#39; -&gt; sppasTier().</span>

<span class="sd">        :param root: (ET) Document root.</span>
<span class="sd">        :param time_slots: (dict)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># list of alignable annotations that are not saved in SPPAS because</span>
        <span class="c"># they don&#39;t have a localization. Their label is added to the closest</span>
        <span class="c"># time-aligned annotations.</span>
        <span class="n">removed_annotations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c"># We first parse only alignable tiers</span>
        <span class="k">for</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__is_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="p">)</span>

        <span class="c"># We then parse alignable-ref tiers</span>
        <span class="k">for</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__is_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="p">)</span>

        <span class="c"># We then parse ref tiers</span>
        <span class="k">for</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__is_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="p">)</span>

        <span class="c"># We have to re-organize tiers: we restore the original rank of each tier</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">)):</span>
            <span class="n">tier_name</span> <span class="o">=</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_tier_index</span><span class="p">(</span><span class="n">tier_name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_tier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier_root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot; Get the element &#39;TIER&#39; -&gt; sppasTier().</span>

<span class="sd">        :param tier_root: (ET) Tier root.</span>
<span class="sd">        :param time_slots: (dict)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The name is used as identifier.</span>
        <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">])</span>

        <span class="c"># meta information (required or optional)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_meta</span><span class="o">.</span><span class="n">set_reverse</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;LINGUISTIC_TYPE_REF&#39;</span><span class="p">,</span> <span class="s">&#39;DEFAULT_LOCALE&#39;</span><span class="p">,</span> <span class="s">&#39;PARTICIPANT&#39;</span><span class="p">,</span> <span class="s">&#39;ANNOTATOR&#39;</span><span class="p">,</span> <span class="s">&#39;LANG_REF&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">tier</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map_meta</span><span class="o">.</span><span class="n">map_entry</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c"># get annotations</span>
        <span class="k">if</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__is_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_ref_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="p">)</span>

        <span class="c"># hierarchy</span>
        <span class="k">if</span> <span class="s">&#39;PARENT_REF&#39;</span> <span class="ow">in</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">parent_tier_name</span> <span class="o">=</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;PARENT_REF&#39;</span><span class="p">]</span>
            <span class="n">parent_tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent_tier_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent_tier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__fix_tiers_hierarchy</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">parent_tier</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_alignable_tier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;TIER&#39; -&gt; sppasTier().</span>

<span class="sd">        :param tier_root: (ET) Tier root.</span>
<span class="sd">        :param tier: (sppasTier) The tier to add the annotation</span>
<span class="sd">        :param time_slots: (dict)</span>
<span class="sd">        :param removed_annotations: (dict) Alignable annotations without time values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Some time slots don&#39;t have a time value, so some annotations do not</span>
        <span class="c"># starts/ends at a given localization.</span>
        <span class="c"># From the SPPAS opinion, it&#39;s not an annotation...</span>
        <span class="n">begin_time</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">annotation_root</span> <span class="ow">in</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;ANNOTATION&#39;</span><span class="p">):</span>

            <span class="c"># In an alignable tier, we expect only alignable annotations</span>
            <span class="n">align_ann_root</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__get_ann_root</span><span class="p">(</span><span class="n">annotation_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="s">&#39;ALIGNABLE_ANNOTATION&#39;</span><span class="p">)</span>

            <span class="c"># The (only) &#39;annotation value&#39; in Elan is a text of a tag of a &#39;label&#39; in SPPAS.</span>
            <span class="c"># Store in a list of labels.</span>
            <span class="n">value_node</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;ANNOTATION_VALUE&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_node</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_node</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

            <span class="c"># Localization</span>
            <span class="k">if</span> <span class="n">begin_time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">begin_key</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_SLOT_REF1&#39;</span><span class="p">]</span>
                <span class="n">begin_time</span> <span class="o">=</span> <span class="n">time_slots</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">begin_key</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">end_key</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_SLOT_REF2&#39;</span><span class="p">]</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="n">time_slots</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">end_key</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c"># If the annotation has a localization, we can create it.</span>
            <span class="k">if</span> <span class="n">begin_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_ann_in_tier</span><span class="p">(</span><span class="n">begin_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># the first removed annotation is the one we use to store metadata</span>
                    <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__add_meta_in_ann</span><span class="p">(</span><span class="n">removed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ann</span><span class="p">)</span>
                    <span class="n">removed</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">align_ann_root</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__add_meta_in_ann</span><span class="p">(</span><span class="n">align_ann_root</span><span class="p">,</span> <span class="n">ann</span><span class="p">)</span>

                <span class="c"># update</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                    <span class="n">ann_id</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;ANNOTATION_ID&#39;</span><span class="p">]</span>
                    <span class="n">removed_annotations</span><span class="p">[</span><span class="n">ann_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>

                <span class="c"># prepare for the next annotation</span>
                <span class="n">begin_time</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">removed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">align_ann_root</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;No time value for the annotation {:s} in an alignable tier {:s}&#39;</span>
                             <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;ANNOTATION_ID&#39;</span><span class="p">],</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">()))</span>

    <span class="c"># -----------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__get_ann_root</span><span class="p">(</span><span class="n">annotation_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="n">align_ann_root</span> <span class="o">=</span> <span class="n">annotation_root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">align_ann_root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AioFormatError</span><span class="p">(</span><span class="s">&#39;TIER: {:s}: ANNOTATION:{:s}&#39;</span>
                                 <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">element</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">align_ann_root</span>

    <span class="c"># -----------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__add_ann_in_tier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">text_list</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="n">localization</span> <span class="o">=</span> <span class="n">sppasInterval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_point</span><span class="p">(</span><span class="n">begin_time</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">make_point</span><span class="p">(</span><span class="n">end_time</span><span class="p">))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">sppasLabel</span><span class="p">(</span><span class="n">sppasTag</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">format_labels</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text_list</span><span class="p">),</span> <span class="n">separator</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">ann</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">create_annotation</span><span class="p">(</span><span class="n">sppasLocation</span><span class="p">(</span><span class="n">localization</span><span class="p">),</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ann</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__add_meta_in_ann</span><span class="p">(</span><span class="n">ann_root</span><span class="p">,</span> <span class="n">ann</span><span class="p">):</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;ANNOTATION_ID&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;SVG_REF&#39;</span><span class="p">,</span> <span class="s">&#39;EXT_REF&#39;</span><span class="p">,</span> <span class="s">&#39;LANG_REF&#39;</span><span class="p">,</span> <span class="s">&#39;CVE_REF&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                <span class="n">ann</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="n">ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">attrib</span><span class="p">])</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__fix_tiers_hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">parent_tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Try to link tier/parent_tier into a hierarchy. &quot;&quot;&quot;</span>

        <span class="n">linked</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">link_type</span> <span class="o">=</span> <span class="n">sppasHierarchy</span><span class="o">.</span><span class="n">infer_hierarchy_type</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">parent_tier</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">link_type</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hierarchy_link</span><span class="p">(</span><span class="n">link_type</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">parent_tier</span><span class="p">)</span>
                <span class="n">linked</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">linked</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">link_type</span> <span class="o">=</span> <span class="n">sppasHierarchy</span><span class="o">.</span><span class="n">infer_hierarchy_type</span><span class="p">(</span><span class="n">parent_tier</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">link_type</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_hierarchy_link</span><span class="p">(</span><span class="n">link_type</span><span class="p">,</span> <span class="n">parent_tier</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>
                    <span class="n">linked</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="n">linked</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;No parent/ref link can be established &quot;</span>
                         <span class="s">&quot;between tiers {:s} and {:s}.&quot;</span>
                         <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">parent_tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">()))</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_parse_ref_tier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">removed_annotations</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot; Get the elements &#39;TIER&#39;.</span>

<span class="sd">        :param tier_root: (ET) Tier root element.</span>
<span class="sd">        :param tier: (sppasTier) The tier to add the annotations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># we expect that the parent tier has already been included in self</span>
        <span class="n">parent_tier_ref</span> <span class="o">=</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;PARENT_REF&#39;</span><span class="p">]</span>
        <span class="n">parent_tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parent_tier_ref</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent_tier</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AioFormatError</span><span class="p">(</span><span class="s">&#39;tier:{:s} parent:{:s}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">parent_tier_ref</span><span class="p">))</span>

        <span class="c"># while we have the aligned parent, we can fill the child tier</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">annotation_root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tier_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;ANNOTATION&#39;</span><span class="p">)):</span>

            <span class="n">ref_ann_root</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__get_ann_root</span><span class="p">(</span><span class="n">annotation_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="s">&#39;REF_ANNOTATION&#39;</span><span class="p">)</span>
            <span class="n">ann_ref_id</span> <span class="o">=</span> <span class="n">ref_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;ANNOTATION_REF&#39;</span><span class="p">]</span>

            <span class="n">ann_ref</span> <span class="o">=</span> <span class="n">parent_tier</span><span class="o">.</span><span class="n">get_annotation</span><span class="p">(</span><span class="n">removed_annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ann_ref_id</span><span class="p">,</span> <span class="n">ann_ref_id</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ann_ref</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AioFormatError</span><span class="p">(</span><span class="s">&#39;tier:{:s} annotation:{:s}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">ann_ref_id</span><span class="p">))</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">sppasLabel</span><span class="p">(</span><span class="n">sppasTag</span><span class="p">(</span><span class="n">ref_ann_root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;ANNOTATION_VALUE&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ann_ref_id</span> <span class="ow">in</span> <span class="n">removed_annotations</span><span class="p">:</span>
                <span class="c"># we append the label like it&#39;s done into the reference, instead of</span>
                <span class="c"># creating a new annotation. We suppose that the annotation to be</span>
                <span class="c"># appended is the last alignable annotation that we previously saved</span>
                <span class="c"># (because annotations are time-sorted)... is it a strong hypothesis?</span>
                <span class="c"># to be verified.</span>
                <span class="n">tier</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Label {:s} appended to annotation {:s}.&#39;</span>
                             <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">get_best</span><span class="p">()</span><span class="o">.</span><span class="n">get_content</span><span class="p">(),</span> <span class="n">tier</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">ann_ref</span><span class="o">.</span><span class="n">get_location</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_ann</span> <span class="o">=</span> <span class="n">sppasAnnotation</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">tier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ann</span><span class="p">)</span>
                <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__add_meta_in_ann</span><span class="p">(</span><span class="n">ref_ann_root</span><span class="p">,</span> <span class="n">new_ann</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>
    <span class="c"># writer</span>
    <span class="c"># -----------------------------------------------------------------------</span>

<div class="viewcode-block" id="sppasEAF.write"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write an ELAN EAF file.</span>

<span class="sd">        :param filename: output filename.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># 1. Document</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_format_document</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="mf">0.001</span>

        <span class="c"># 2. License</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_license</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 3. Header: media, linked media, property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_header</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 4. Time Order: we only create the main element</span>
        <span class="n">time_order_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;TIME_ORDER&#39;</span><span class="p">)</span>

        <span class="c"># 5. Tiers</span>

        <span class="c"># 5.1 Create the root of each tier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_tier_root</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="c"># 5.2 Fill alignable tiers with their annotations</span>
        <span class="n">alignable_tiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_alignable_tiers</span><span class="p">()</span>
        <span class="n">time_slots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_alignable_tiers</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">alignable_tiers</span><span class="p">)</span>
        <span class="c"># 5.3 Fill reference tiers with their annotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_reference_tiers</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">alignable_tiers</span><span class="p">)</span>

        <span class="c"># 5.4 Now that tiers are filled in the tree,</span>
        <span class="c"># we can generate properly the list of time slots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_time_slots</span><span class="p">(</span><span class="n">time_order_root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">)</span>

        <span class="c"># 6. Linguistic Types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_linguistic_types</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 7. Locale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_locales</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 8. Language</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_languages</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 9. Constraint</span>
        <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_format_constraints</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c"># 10. Controlled vocabulary</span>
        <span class="k">for</span> <span class="n">ctrl_vocab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ctrl_vocab_list</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_format_ctrl_vocab</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="p">)</span>

        <span class="c"># 11. Lexicon ref</span>

        <span class="c"># 12. External ref</span>

        <span class="n">sppasEAF</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sppas</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;xml&quot;</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_document</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot; Create a root element tree for EAF format. &quot;&quot;&quot;</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s">&#39;ANNOTATION_DOCUMENT&#39;</span><span class="p">)</span>
        <span class="n">author</span> <span class="o">=</span> <span class="n">sppas</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">sppas</span><span class="o">.</span><span class="n">__version__</span> <span class="o">+</span> <span class="s">&quot; (C) &quot;</span> <span class="o">+</span> <span class="n">sppas</span><span class="o">.</span><span class="n">__author__</span>

        <span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;AUTHOR&#39;</span><span class="p">,</span> <span class="n">author</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;DATE&#39;</span><span class="p">,</span> <span class="n">sppasTime</span><span class="p">()</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s">&#39;3.0&#39;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;VERSION&#39;</span><span class="p">,</span> <span class="s">&#39;3.0&#39;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;xmlns:xsi&#39;</span><span class="p">,</span>
                 <span class="s">&#39;http://www.w3.org/2001/XMLSchema-instance&#39;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;xsi:noNamespaceSchemaLocation&#39;</span><span class="p">,</span>
                 <span class="s">&#39;http://www.mpi.nl.tools/elan/EAFv3.0.xsd&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">root</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_license</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add an element &#39;LICENSE&#39; into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :returns: (ET) License root.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># we have to restore the licenses in their original order.</span>
        <span class="n">licenses</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="s">&#39;file_license_text&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">url</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">url_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">url_key</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;text&#39;</span><span class="p">,</span> <span class="s">&#39;url&#39;</span><span class="p">):</span>
                        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">url_key</span><span class="p">)</span>
                <span class="n">licenses</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">url</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">licenses</span><span class="p">):</span>
                <span class="n">license_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&quot;LICENSE&quot;</span><span class="p">)</span>
                <span class="n">license_root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">licenses</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">license_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LICENSE_URL&#39;</span><span class="p">,</span> <span class="n">licenses</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_languages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;LANGUAGE&#39; into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :returns: (ET) License root.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># we restore the languages in their original order.</span>

        <span class="c"># store all languages in a dictionary</span>
        <span class="n">languages</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;language_code_&#39;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">url</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key2</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;code&#39;</span><span class="p">,</span> <span class="s">&#39;url&#39;</span><span class="p">):</span>
                        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key2</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;code&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">):</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key2</span><span class="p">)</span>
                <span class="n">languages</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>

        <span class="c"># add the languages of the dictionary into the tree</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">languages</span><span class="p">)):</span>
            <span class="n">language_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&quot;LANGUAGE&quot;</span><span class="p">)</span>
            <span class="n">language_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LANG_ID&#39;</span><span class="p">,</span> <span class="n">languages</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">languages</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">language_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LANG_LABEL&#39;</span><span class="p">,</span> <span class="n">languages</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">languages</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">language_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LANG_DEF&#39;</span><span class="p">,</span> <span class="n">languages</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add &#39;HEADER&#39; into the ElementTree. &quot;&quot;&quot;</span>

        <span class="n">header_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;HEADER&#39;</span><span class="p">)</span>
        <span class="n">header_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_UNITS&#39;</span><span class="p">,</span> <span class="s">&#39;milliseconds&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">media</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_media_list</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_format_media</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="n">media</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">media</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_media_list</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_format_linked_media</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="n">media</span><span class="p">)</span>

        <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_format_property</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_media</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">media</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add &#39;MEDIA_DESCRIPTOR&#39; into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :param media: (sppasMedia)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># do not add the media if it&#39;s not a primary one</span>
        <span class="k">if</span> <span class="n">media</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="s">&#39;media_source&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">media</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;media_source&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;primary&#39;</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">media_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;MEDIA_DESCRIPTOR&#39;</span><span class="p">)</span>

        <span class="c"># Write all the elements SPPAS has interpreted (required by EAF)</span>
        <span class="n">media_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;MEDIA_URL&#39;</span><span class="p">,</span> <span class="n">media</span><span class="o">.</span><span class="n">get_filename</span><span class="p">())</span>
        <span class="n">media_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;MIME_TYPE&#39;</span><span class="p">,</span> <span class="n">media</span><span class="o">.</span><span class="n">get_mime_type</span><span class="p">())</span>

        <span class="c"># other EAF optional elements</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RELATIVE_MEDIA_URL&#39;</span><span class="p">,</span> <span class="s">&#39;TIME_ORIGIN&#39;</span><span class="p">,</span> <span class="s">&#39;EXTRACTED_FROM&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">media</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">media_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">media</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_linked_media</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">media</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add &#39;LINKED_FILE_DESCRIPTOR&#39; into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :param media: (sppasMedia)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># do not add the media if it&#39;s a primary one</span>
        <span class="k">if</span> <span class="n">media</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="s">&#39;media_source&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">media</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;media_source&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;primary&#39;</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">media_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;LINKED_FILE_DESCRIPTOR&#39;</span><span class="p">)</span>

        <span class="c"># Write all the elements SPPAS has interpreted (required by EAF)</span>
        <span class="n">media_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINK_URL&#39;</span><span class="p">,</span> <span class="n">media</span><span class="o">.</span><span class="n">get_filename</span><span class="p">())</span>
        <span class="n">media_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;MIME_TYPE&#39;</span><span class="p">,</span> <span class="n">media</span><span class="o">.</span><span class="n">get_mime_type</span><span class="p">())</span>

        <span class="c"># other EAF optional elements</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RELATIVE_LINK_URL&#39;</span><span class="p">,</span> <span class="s">&#39;TIME_ORIGIN&#39;</span><span class="p">,</span> <span class="s">&#39;ASSOCIATED_WITH&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">media</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">media_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">media</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_property</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="n">meta_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add &#39;PROPERTY&#39; elements into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">meta_object</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;id&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meta_object</span><span class="p">,</span> <span class="n">sppasMedia</span><span class="p">):</span>
                    <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__add_property</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span>
                                            <span class="s">&quot;media_id_&quot;</span><span class="o">+</span><span class="n">meta_object</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(),</span>
                                            <span class="n">meta_object</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meta_object</span><span class="p">,</span> <span class="n">sppasTier</span><span class="p">):</span>
                    <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__add_property</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span>
                                            <span class="s">&quot;tier_id_&quot;</span> <span class="o">+</span> <span class="n">meta_object</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                                            <span class="n">meta_object</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">))</span>
                <span class="c"># we can&#39;t preserve the &#39;id&#39; of other objects</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># ignore the metadata that are interpreted by other methods.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;language_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;locale_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;file_license_&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__add_property</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">meta_object</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__add_property</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">property_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">header_root</span><span class="p">,</span> <span class="s">&#39;PROPERTY&#39;</span><span class="p">)</span>
        <span class="n">property_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;NAME&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">property_root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_linguistic_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;LINGUISTIC_TYPES&#39; into the ElementTree.</span>

<span class="sd">        :param root: (ElementTree)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;LINGUISTIC_TYPE&#39;</span><span class="p">)</span>
        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_ID&#39;</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">)</span>
        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_ALIGNABLE&#39;</span><span class="p">,</span> <span class="s">&#39;true&#39;</span><span class="p">)</span>
        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;GRAPHIC_REFERENCES&#39;</span><span class="p">,</span> <span class="s">&#39;false&#39;</span><span class="p">)</span>

        <span class="c"># fix the linguistic type of each tier</span>
        <span class="c"># we always have to search for a controlled vocabulary</span>
        <span class="k">for</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>

            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">tier</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ctrl_vocab</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_ctrl_vocab</span><span class="p">()</span>

            <span class="n">is_alignable</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">__is_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">)</span>
            <span class="c"># alignable tiers without parent (= default linguistic type)</span>
            <span class="k">if</span> <span class="n">is_alignable</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ctrl_vocab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">linguistic_type_id</span> <span class="o">=</span> <span class="s">&quot;a_&quot;</span><span class="o">+</span><span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
                    <span class="n">tier_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_REF&#39;</span><span class="p">,</span> <span class="n">linguistic_type_id</span><span class="p">)</span>

                    <span class="n">exists</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="c"># already existing?</span>
                    <span class="k">for</span> <span class="n">ling_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE&#39;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">linguistic_type_id</span> <span class="o">==</span> <span class="n">ling_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;LINGUISTIC_TYPE_ID&#39;</span><span class="p">]:</span>
                            <span class="n">exists</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">:</span>
                        <span class="c"># create it:</span>
                        <span class="n">default_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;LINGUISTIC_TYPE&#39;</span><span class="p">)</span>
                        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_ID&#39;</span><span class="p">,</span> <span class="n">linguistic_type_id</span><span class="p">)</span>
                        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_ALIGNABLE&#39;</span><span class="p">,</span> <span class="s">&#39;true&#39;</span><span class="p">)</span>
                        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;GRAPHIC_REFERENCES&#39;</span><span class="p">,</span> <span class="s">&#39;false&#39;</span><span class="p">)</span>
                        <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CONTROLLED_VOCABULARY_REF&#39;</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>

            <span class="c"># alignable tiers with a parent</span>
            <span class="k">elif</span> <span class="n">is_alignable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># ref tiers</span>
            <span class="k">elif</span> <span class="n">is_alignable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">linguistic_type_id</span> <span class="o">=</span> <span class="s">&quot;r_&quot;</span> <span class="o">+</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
                <span class="n">tier_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_REF&#39;</span><span class="p">,</span> <span class="n">linguistic_type_id</span><span class="p">)</span>

                <span class="n">default_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;LINGUISTIC_TYPE&#39;</span><span class="p">)</span>
                <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_ID&#39;</span><span class="p">,</span> <span class="n">linguistic_type_id</span><span class="p">)</span>
                <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CONSTRAINTS&#39;</span><span class="p">,</span> <span class="s">&quot;Symbolic_Association&quot;</span><span class="p">)</span>
                <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_ALIGNABLE&#39;</span><span class="p">,</span> <span class="s">&#39;false&#39;</span><span class="p">)</span>
                <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;GRAPHIC_REFERENCES&#39;</span><span class="p">,</span> <span class="s">&#39;false&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ctrl_vocab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">default_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CONTROLLED_VOCABULARY_REF&#39;</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_locales</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;LOCALE&#39; into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># we have to restore the locales in their original order.</span>
        <span class="n">locales</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;locale_code_&#39;</span><span class="p">):</span>
                <span class="n">country</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">variant</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key2</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;code&#39;</span><span class="p">,</span> <span class="s">&quot;country&quot;</span><span class="p">):</span>
                        <span class="n">country</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key2</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;code&#39;</span><span class="p">,</span> <span class="s">&quot;variant&quot;</span><span class="p">):</span>
                        <span class="n">variant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key2</span><span class="p">)</span>
                <span class="n">locales</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">country</span><span class="p">,</span> <span class="n">variant</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">locales</span><span class="p">):</span>
            <span class="n">locale_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&quot;LOCALE&quot;</span><span class="p">)</span>
            <span class="n">locale_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LANGUAGE_CODE&#39;</span><span class="p">,</span> <span class="n">locales</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">locales</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">locale_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;COUNTRY_CODE&#39;</span><span class="p">,</span> <span class="n">locales</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">locales</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">locale_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;VARIANT&#39;</span><span class="p">,</span> <span class="n">locales</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_constraints</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;CONSTRAINTS&#39; into the ElementTree.</span>

<span class="sd">        :param root: (ElementTree)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">stereotype</span> <span class="ow">in</span> <span class="n">CONSTRAINTS</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="n">CONSTRAINTS</span><span class="p">[</span><span class="n">stereotype</span><span class="p">]</span>
            <span class="n">type_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;CONSTRAINT&#39;</span><span class="p">)</span>
            <span class="n">type_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;DESCRIPTION&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>
            <span class="n">type_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;STEREOTYPE&#39;</span><span class="p">,</span> <span class="n">stereotype</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_ctrl_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add &#39;CONTROLLED_VOCABULARY&#39; elements into the ElementTree (if any).</span>

<span class="sd">        :param root: (ElementTree)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ctrl_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;CONTROLLED_VOCABULARY&#39;</span><span class="p">)</span>
        <span class="n">ctrl_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CV_ID&#39;</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="s">&#39;EXT_REF&#39;</span><span class="p">):</span>
            <span class="n">ctrl_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;EXT_REF&#39;</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;EXT_REF&#39;</span><span class="p">))</span>

        <span class="n">language</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;language_code_0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="s">&#39;language_code_0&#39;</span><span class="p">):</span>
            <span class="n">language</span> <span class="o">=</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;language_code_0&#39;</span><span class="p">)</span>

        <span class="n">description</span> <span class="o">=</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_description</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">desc_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">ctrl_root</span><span class="p">,</span> <span class="s">&quot;DESCRIPTION&quot;</span><span class="p">)</span>
            <span class="n">desc_root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">description</span>
            <span class="n">desc_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LANG_REF&#39;</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ctrl_vocab</span><span class="p">):</span>
            <span class="n">entry_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">ctrl_root</span><span class="p">,</span> <span class="s">&#39;CV_ENTRY_ML&#39;</span><span class="p">)</span>
            <span class="n">entry_value_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">entry_root</span><span class="p">,</span> <span class="s">&#39;CVE_VALUE&#39;</span><span class="p">)</span>
            <span class="n">entry_value_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CVE_ID&#39;</span><span class="p">,</span> <span class="s">&quot;cveid</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">entry_value_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;DESCRIPTION&#39;</span><span class="p">,</span> <span class="n">ctrl_vocab</span><span class="o">.</span><span class="n">get_tag_description</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
            <span class="n">entry_value_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LANG_REF&#39;</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
            <span class="n">entry_value_root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">get_content</span><span class="p">()</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_time_slots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_order_root</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fill the TIME_ORDER element with time slots.</span>

<span class="sd">        :param time_order_root: (ET)</span>
<span class="sd">        :param time_slots: (dict) The link between time values/tier and time slots.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">time_value</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span> <span class="ow">in</span> <span class="n">time_slots</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">time_slots</span><span class="p">[(</span><span class="n">time_value</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">tier</span><span class="p">)]</span>
            <span class="n">ts_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">time_order_root</span><span class="p">,</span> <span class="s">&#39;TIME_SLOT&#39;</span><span class="p">)</span>
            <span class="n">ts_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_ID&#39;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">milliseconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_point</span><span class="p">(</span><span class="n">time_value</span><span class="p">)</span>
                <span class="n">ts_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_VALUE&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">milliseconds</span><span class="p">))</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_tier_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create the root of each tier. Do not fill at all.</span>

<span class="sd">        It allows to preserve the rank of each tier in the tree and to fill</span>
<span class="sd">        all-in-one alignable-tiers then ref-tiers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tier</span><span class="o">.</span><span class="n">is_disjoint</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">tier_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#39;TIER&#39;</span><span class="p">)</span>
                <span class="n">tier_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
                <span class="n">tier_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;LINGUISTIC_TYPE_REF&#39;</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_alignable_tiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">alignable_tiers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;TIER&#39; into the ElementTree (if any).</span>
<span class="sd">        Only for alignable tiers.</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :param alignable_tiers: (list)</span>
<span class="sd">        :returns: (dict) Time slots</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># no tier, nothing to do!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="n">min_time_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_min_loc</span><span class="p">()</span>
        <span class="n">max_time_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_loc</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">min_time_point</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">max_time_point</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># only empty tiers in the transcription: nothing to add in the tree</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c"># we have to remove the hierarchy because instead we can&#39;t merge</span>
        <span class="c"># overlapping annotations</span>
        <span class="n">hierarchy_backup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hierarchy</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_hierarchy</span><span class="p">()</span><span class="o">.</span><span class="n">remove_tier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="n">new_alignable_tiers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c"># not a relevant tier</span>
            <span class="k">if</span> <span class="n">tier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alignable_tiers</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c"># create the new tier (no overlaps, no points, no disjoint)</span>
            <span class="k">if</span> <span class="n">tier</span><span class="o">.</span><span class="n">is_interval</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">new_tier</span> <span class="o">=</span> <span class="n">merge_overlapping_annotations</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tier</span><span class="o">.</span><span class="n">is_point</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">new_tier</span> <span class="o">=</span> <span class="n">point2interval</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_tier</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">))</span>
            <span class="n">new_alignable_tiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tier</span><span class="p">)</span>

        <span class="c"># create the annotations</span>
        <span class="n">time_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="n">new_alignable_tiers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">():</span>
                    <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_format_alignable_annotations</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">time_values</span><span class="p">)</span>

        <span class="c"># assign time slots to annotations</span>
        <span class="n">time_slots</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_fix_time_slots</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span>

        <span class="c"># then, we can assign the time slots to annotations, instead of time values</span>
        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="n">new_alignable_tiers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tier_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">():</span>
                    <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_re_format_alignable_annotations</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">)</span>

        <span class="c"># restore the hierarchy...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hierarchy</span> <span class="o">=</span> <span class="n">hierarchy_backup</span>

        <span class="k">return</span> <span class="n">time_slots</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_format_alignable_annotations</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">time_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;ANNOTATION&#39; into the ElementTree (if any).</span>
<span class="sd">        Only for alignable tiers.</span>

<span class="sd">        Attention: we assign time values instead of time slots. An annotation</span>
<span class="sd">        without time value has &#39;none&#39; instead.</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :param tier: (sppasTier)</span>
<span class="sd">        :param time_values: (list of float) The list of time values (midpoint)</span>
<span class="sd">        of the tiers. Is completed in this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">tier</span><span class="p">:</span>

            <span class="c"># create an ANNOTATION for each label.</span>
            <span class="c"># specific time slots will have to be generated for un-aligned annotations.</span>
            <span class="n">created_anns</span> <span class="o">=</span> <span class="n">sppasEAF</span><span class="o">.</span><span class="n">_create_alignable_annotation_element</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">tier_root</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">align_ann_root</span> <span class="ow">in</span> <span class="n">created_anns</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_SLOT_REF1&#39;</span><span class="p">]</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIME_SLOT_REF2&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="s">&#39;_none_&#39;</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">b_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="n">b_rank</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="s">&#39;_none_&#39;</span> <span class="ow">in</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">e_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">e_rank</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c"># we save only once a couple (time_value, rank, tier).</span>
                <span class="c"># it allows to link consecutive annotations.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b_rank</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">time_values</span><span class="p">:</span>
                    <span class="n">time_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">b_rank</span><span class="p">,</span> <span class="n">tier</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">e_rank</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">time_values</span><span class="p">:</span>
                    <span class="n">time_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">e_rank</span><span class="p">,</span> <span class="n">tier</span><span class="p">))</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_alignable_annotation_element</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">tier_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create ANNOTATION in ElementTree.</span>
<span class="sd">        Returns the list of created nodes of &#39;ALIGNABLE_ANNOTATION&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">get_lowest_localization</span><span class="p">()</span><span class="o">.</span><span class="n">get_midpoint</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">get_highest_localization</span><span class="p">()</span><span class="o">.</span><span class="n">get_midpoint</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c"># a label (and only one) is required in an annotation</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_labels</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">sppasLabel</span><span class="p">(</span><span class="n">sppasTag</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">))]</span>

        <span class="n">created_anns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>

            <span class="n">ann_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="s">&quot;ANNOTATION&quot;</span><span class="p">)</span>
            <span class="n">align_ann_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">ann_root</span><span class="p">,</span> <span class="s">&#39;ALIGNABLE_ANNOTATION&#39;</span><span class="p">)</span>

            <span class="c"># Assign the location (will eventually be override)</span>
            <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_REF1&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_none_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_REF2&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_none_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ANNOTATION_ID&#39;</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ANNOTATION_ID&#39;</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;SVG_REF&#39;</span><span class="p">,</span> <span class="s">&#39;EXT_REF&#39;</span><span class="p">,</span> <span class="s">&#39;LANG_REF&#39;</span><span class="p">,</span> <span class="s">&#39;CVE_REF&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ann</span><span class="o">.</span><span class="n">is_meta_key</span><span class="p">(</span><span class="n">attrib</span><span class="p">):</span>
                    <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">attrib</span><span class="p">))</span>

            <span class="c"># Assign the label</span>
            <span class="n">label_ann_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">align_ann_root</span><span class="p">,</span> <span class="s">&#39;ANNOTATION_VALUE&#39;</span><span class="p">)</span>
            <span class="n">label_ann_root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">empty</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># get_best().get_content()</span>

            <span class="n">created_anns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">align_ann_root</span><span class="p">)</span>

        <span class="c"># Override the begin/end to the first/last created alignable annotations</span>
        <span class="n">created_anns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_REF1&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">begin</span><span class="p">))</span>
        <span class="n">created_anns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_REF2&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">created_anns</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_re_format_alignable_annotations</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">time_slots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Replace time values instead of time slots in &#39;ANNOTATION&#39; elements.</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :param tier: (sppasTier)</span>
<span class="sd">        :param time_slots: (dict) The link between (time values/tier) and time slots.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ann_root</span> <span class="ow">in</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;ANNOTATION&#39;</span><span class="p">):</span>
            <span class="n">align_ann_root</span> <span class="o">=</span> <span class="n">ann_root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;ALIGNABLE_ANNOTATION&#39;</span><span class="p">)</span>

            <span class="c"># get the time values we previously assigned.</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&quot;TIME_SLOT_REF1&quot;</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">align_ann_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&quot;TIME_SLOT_REF2&quot;</span><span class="p">]</span>

            <span class="c"># fix the appropriate time slot</span>
            <span class="k">if</span> <span class="s">&quot;_none_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">begin</span><span class="p">:</span>
                <span class="n">ts_begin</span> <span class="o">=</span> <span class="n">time_slots</span><span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tier</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ts_begin</span> <span class="o">=</span> <span class="n">time_slots</span><span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">begin</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">begin</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">tier</span><span class="p">)]</span>

            <span class="k">if</span> <span class="s">&quot;_none_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">ts_end</span> <span class="o">=</span> <span class="n">time_slots</span><span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tier</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ts_end</span> <span class="o">=</span> <span class="n">time_slots</span><span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">end</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">tier</span><span class="p">)]</span>

            <span class="c"># replace by the time slot in the tree</span>
            <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_REF1&#39;</span><span class="p">,</span> <span class="n">ts_begin</span><span class="p">)</span>
            <span class="n">align_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TIME_SLOT_REF2&#39;</span><span class="p">,</span> <span class="n">ts_end</span><span class="p">)</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_fix_alignable_tiers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the list of tiers to be aligned in time (without annotation ref). &quot;&quot;&quot;</span>

        <span class="n">alignable</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">is_alignable</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c"># check labels (if several labels in an annotation =&gt; alignable tier)</span>
            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">tier</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">get_labels</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">is_alignable</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>

            <span class="c"># check hierarchy (if child in a TimeAssociation =&gt; reference tier)</span>
            <span class="k">if</span> <span class="n">is_alignable</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">is_alignable</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">parent_tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hierarchy</span><span class="p">()</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parent_tier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">link_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hierarchy</span><span class="p">()</span><span class="o">.</span><span class="n">get_hierarchy_type</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">link_type</span> <span class="o">==</span> <span class="s">&quot;TimeAssociation&quot;</span><span class="p">:</span>
                        <span class="n">is_alignable</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">is_alignable</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">alignable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">alignable</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_format_reference_tiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">alignable_tiers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add the elements &#39;TIER&#39; into the ElementTree (if any).</span>
<span class="sd">        Only for reference tiers (annotations are not aligned but reference).</span>

<span class="sd">        :param root: (ElementTree)</span>
<span class="sd">        :returns: (dict) Time slots</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># no tier, nothing to do!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c"># all tiers are aligned, nothing to do!</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignable_tiers</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tier</span> <span class="ow">in</span> <span class="n">alignable_tiers</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">tier_root</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">t_root</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;TIER&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">t_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;TIER_ID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">():</span>
                    <span class="n">tier_root</span> <span class="o">=</span> <span class="n">t_root</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">tier_root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c"># necessarily, this tier has a parent in the hierarchy.</span>
            <span class="n">parent_tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hierarchy</span><span class="p">()</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>
            <span class="n">tier_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;PARENT_REF&#39;</span><span class="p">,</span> <span class="n">parent_tier</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">tier</span><span class="p">:</span>
                <span class="n">begin_value</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_lowest_localization</span><span class="p">()</span>
                <span class="n">end_value</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_highest_localization</span><span class="p">()</span>
                <span class="n">parent_ann</span> <span class="o">=</span> <span class="n">parent_tier</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">begin_value</span><span class="p">,</span> <span class="n">end_value</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_ann</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Failed to find one annotation reference for {:s}. &quot;</span>
                                 <span class="s">&quot;Found: {:s}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">parent_ann</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="n">AioFormatError</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
                <span class="n">parent_id</span> <span class="o">=</span> <span class="n">parent_ann</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>

                <span class="n">ann_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">tier_root</span><span class="p">,</span> <span class="s">&quot;ANNOTATION&quot;</span><span class="p">)</span>
                <span class="n">ref_ann_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">ann_root</span><span class="p">,</span> <span class="s">&quot;REF_ANNOTATION&quot;</span><span class="p">)</span>
                <span class="n">ref_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ANNOTATION_ID&#39;</span><span class="p">,</span> <span class="n">ann</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">))</span>
                <span class="n">ref_ann_root</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ANNOTATION_REF&#39;</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">)</span>

                <span class="c"># Assign the label</span>
                <span class="n">label_ann_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">ref_ann_root</span><span class="p">,</span> <span class="s">&#39;ANNOTATION_VALUE&#39;</span><span class="p">)</span>
                <span class="n">label_ann_root</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">serialize_labels</span><span class="p">()</span>

    <span class="c"># -----------------------------------------------------------------------</span>
    <span class="c"># PRIVATE</span>
    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fix_time_slots</span><span class="p">(</span><span class="n">time_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Time values is a list of (float, int, sppasTier). &quot;&quot;&quot;</span>

        <span class="c"># sort by time values and assign the &#39;ts&lt;num&gt;&#39; id</span>
        <span class="n">time_slots</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">time_values</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="s">&#39;ts</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span>
            <span class="n">time_slots</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span>

        <span class="k">return</span> <span class="n">time_slots</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__is_alignable_tier</span><span class="p">(</span><span class="n">tier_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return 0/False if the tier is not time-alignable at all. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;PARENT_REF&#39;</span> <span class="ow">in</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">annotation_root</span> <span class="ow">in</span> <span class="n">tier_root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;ANNOTATION&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">annotation_root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;REF_ANNOTATION&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># a time-alignable tier with a parent.</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># a reference tier with a parent, not directly time-alignable.</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="c"># a time-alignable tier, without parent.</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="c"># -----------------------------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="sppasEAF.indent"><a class="viewcode-back" href="../../../rst/anndata.aio.html#anndata.aio.elan.sppasEAF.indent">[docs]</a>    <span class="k">def</span> <span class="nf">indent</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pretty indent.</span>
<span class="sd">        http://effbot.org/zone/element-lib.htm#prettyprint</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">level</span> <span class="o">*</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">elem</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">i</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                <span class="n">sppasEAF</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                <span class="n">elem</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">i</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SPPAS 1.9.8 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Copyright (C) 2011-2018 Brigitte Bigi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>